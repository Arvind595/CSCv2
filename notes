Wed 11 Oct 08:08:10 AEST 2017
-----------------------------
Chris Baird showed a way to do function calls, but to make it more efficient
I need a new ALU operation. So it's time to bite the bullet and upgrade to
16 ALU operations. I've cloned CSC version 1 to this version, version 2.
I've made the wiring change to the logisim version and csim, but I haven't
defined the new ALU operations yet. Time to scribble on paper.

We have to worry about the Asel line, so there are two banks of eight ALU
operations. Here are the ones we need to keep from CSCv1:

    Operation		Result
    --------------------------
    ALUinca		A + 1
    ALUpassb		B
    ALUpassa		A
    ALUxor		A ^ B
    ALUdadd		A + B decimal
    ALUor		A | B
    ALUand		A & B
    ALUsub		A - B binary
    ALUadd		A + B binary

I want to bring in at least:

    ALUdsub		A - B decimal
    ALUbflags		anything, but flags set to B

That leaves five more operations. I'd suggest at least these four:

    ALUmullo		A * B binary, low  4 bits
    ALUmulhi		A * B binary, high 4 bits
    ALUdiv		A / B
    ALUmod		A % B

Are there other operations that would be more useful?

Looking at the existing uses of the ALU, along with the Asel control line,
we have to at least these operations when Asel is on: ALUadd, ALUpassa
and ALUpassb. So let's try to partition up the possible operations:

  Asel off		Asel on
---------------------------------
  ALUdadd		ALUadd
  ALUdsub		ALUsub
  ALUand		ALUpassa
  ALUop			ALUpassb
  ALUxor		ALUmullo
  ALUinca		ALUmulhi
  ALUbflags		ALUdiv
  <unallocated>		ALUmod

For now, I might put in ALUzero (output is zero) as the final operation,
and temporarily implement this in cas and csim, and make sure the old
programs can be reassembled and still work. I still need to work out what
useful result we can have for ALUbflags. For now, zero.

Wed 11 Oct 10:35:49 AEST 2017
-----------------------------
Right, I've made the changes, and I've tested that fibminksy still runs
under the new system. That doesn't means it is perfect yet, but it's a
start. Now to start defining some new instructions. hexbench2 also still
runs, which is excellent.

Wed 11 Oct 11:14:59 AEST 2017
-----------------------------
I wrote a test function with four callers, and it actually worked first
time, that is so excellent! It's called firstfunction.s.

I've added some more CPU instructions that use the new ALU operations.
I've just added the extra wire from the top ROM Asel output to A12 of
the ALU ROM. This is the "bank select" control line for the two banks
of eight ALU operations.

Hmm, I noticed that fibminsky stopped working. It was my change to
the CLC control lines. I've reverted to the old set of control lines,
but I should work out why it isn't working with the new ones.

Found it. I had a typo on the definition of ZERO, so the new CLC
which uses ALUzero was not right. Fixed.

Wednesday 11 October  18:59:16 AEST 2017
----------------------------------------
I decided to write up some documentation on the instruction set and
how to write assembly code, in the form of Instructions.md. I'm
happy with it now. I've moved the programs into an Examples directory.

Thursday 12 October  19:58:51 AEST 2017
---------------------------------------
A good day today. I've worked out how to convert and print an 8-bit
unsigned number as three decimal digits. Using this, I've been able
to modify the Minsky code to draw a full circle using VT100 escape
sequences. Chris suggests using the tek4014 escape sequences to
draw real pixels, and has sent me a Mandelbrot program so I can see
the escape sequences. I've updated some of the documentation. I've
added a -c clockrate option to csim, so I can show it down and make
it more like the real hardware. So now I can see it draw the circle
just like the real circuit would.

Friday 13 October  08:49:51 AEST 2017
-------------------------------------
I wrote a small program to explore all the control line combinations
to see which ones might be useful. Removing the duplicate instructions
with the same effect leaves 48 instructions. This doesn't include the
conditional instructions.  Maybe we need to come up with a way to
consistently name them all :)

Some of them I can see would be useful: ZEROMAB to zero A and B at
the same time. No, not useful as that implies a DAB, and we can
already DAB 0 to load A&B with a zero. Removed.

Saturday 14 October  15:28:38 AEST 2017
---------------------------------------
I'm working on a program that enumerates all winning tic tac toe
boards where X moves first. Had some trouble squeezing it into
the 256 instruction limit. Getting close. I can now find this:
181
818
100

but the code progresses on to do this:

181
818
110

Not sure why yet. OK, fixed, and the number of winning boards is
exactly the same as my Perl version, so I'm really happy that the
program produces a correct result.

Sunday 15 October  16:59:22 AEST 2017
-------------------------------------
I tried to write a recursive towers of Hanoi program, but it hurt my
brain too much so I unrolled each level as a separate function. Chris
asked for \ to continue lines, which I have just done. I also fixed
the wrong line numbers report by cas on errors. Now I've edited the
example programs to use \.

Tue 17 Oct 07:40:26 AEST 2017
-----------------------------
Over the past few days I've written a program to print out a
couple of stanzas of "Mel the Programmer", and also a Bubblesort
program. Nothing much else.

Saturday 21 October  09:04:44 AEST 2017
---------------------------------------
I started learning Verilog yesterday and I now have CSCv2 implemented
but not working in Verilog. Current situation: the control ROMs are
decoding the instructions, the A/B/Flags registers seem to work, the ALU
seems to work. I store 1 into RAM location 4 but when I read it back it is
0. $display shows the store and incorrect read. $monitor seems to show
an extra write of 0 into RAM location 4.

Saturday 21 October  12:11:22 AEST 2017
---------------------------------------
Fixed. I had a data_out reg in ram.v which needed to be a wire. Now
I'm getting the lsb column of fibminsky.s working but no carry into
the next column.

That's now fixed too. I wired Cin up to the wrong Flags output bit.
I found that $write can output ASCII characters without a newline.
So now the Verilog version of the CPU can run fibminsky.s! I'm pretty
chuffed that I could get a Verilog version up and running. Oh, and I
can now see the digital lines in GTKwave :) I'll put it up in the
Github repository soon.

Sunday 22 October  08:50:09 AEST 2017
-------------------------------------
Yesterday I decided to make v2 the stable version. I've updated all
the docs on the minnie and Github sites, and pointed everything to
the CSCv2 Github site. This morning Chris suggested I try yosys to
visualise the Verilog synthesis. It all looks good, no glaring errors. 

Sunday 22 October  21:27:23 AEST 2017
-------------------------------------
Heh, got 8-bit multiplies to work. I fixed a MULLO bug in the process.
Chris says he has wired up the CPU, but needs to build a clock signal
and some output ability.

Mon 23 Oct 10:10:41 AEST 2017
-----------------------------
I fixed up the clc output to reflect the new v2 architecture. Now I'm
thinking if I should try to put functions in :) Something like:

function fred(x) {		// Function declaration, x is optional
}

y= fred(foo);			// Function call, "y=" and "foo" optional

I might start with just functions and local variables.

Mon 23 Oct 14:25:33 AEST 2017
-----------------------------
OK, I have functions, function returns, local variables, one function
parameter and assignment from function returns working. The compiler
is getting as ugly as sin. But it does work! I could take my h2 compiler
and modify it if I want to make it a proper compiler.

Tue 24 Oct 09:34:43 AEST 2017
-----------------------------
I found a few more compiler bugs and fixed them. One had me stumped for
quite a while. Nothing beats pen and paper for debugging :)

A few days ago I had a hard time debugging when the ALU was outputting the
wrong result/flags. I'd fixed gen_alu but the problem still persisted. I'd
forgotten to fix the same bug in csim. To ensure that this never happens
again, I've modified csim to load the ALU ROM image and use that to do the
ALU operations. So now csim should behave exactly the same as the hardware.

Thu 26 Oct 08:10:59 AEST 2017
-----------------------------
I got rid of some DRY code in the compiler yesterday. I did start work
on a proper compiler, using a derivative of my h2 compiler as the basis.
However, I can see that it's going to be too much work, so I stopped.

This morning, I saw Chris Baird's twitter video showing his wire wrap
CPU mostly working, maybe just a couple of broken wires on some of the
LED displays. That's excellent. In browsing the csim source, I realised
that I wasn't displaying the correct ALU operaion in debug mode, now fixed.

Chris thinks he's also having LED current draw issues. Wish there was a
component that was a LED array, LED drivers and limit resistors all in one
unit. I found a way to print two hex digits in 9 instructions, so I've
added prhex() and prhexn() to the compiler to do this.

Thursday 26 October  16:24:12 AEST 2017
---------------------------------------
Just heard from Chris Baird on twitter: he's fixed up some wiring issues
and his wire wrap CSCv2 is now working perfectly. Congrats to him.

Thursday 26 October  16:29:56 AEST 2017
---------------------------------------

Possible 8-bit version of CSC
=============================
This is all hypothetical, but in case someone wants to do it. It should
be possible to build an 8-bit version of the CSC. You'd need:

- 16-bit PC:  Four 74LS161s cascaded together, or two 74LS469s.
- bottom ROM: Two 64Kx8 EEPROMs instead of one 8Kx8 EEPROM.
- top ROM:    One 64Kx8 EEPROM, as the control lines are the same.
	      However, the four NZVC lines will limit PC addressing to
	      12 bits, so you might want to choose 1Mx8 ROMs instead.
- RAM:	      64Kx8 RAM.
- mux:	      Two 74LS157s.
- registers:  You will need two 8-bit registers for A & B, and one 4-bit
	      register for the flags. So some combination of 74LS161s
	      and/or CD4508Bs.
- ALU:	      Two 8Kx8 EEPROMs, with the carry out of the low side
	      connected to Cin on the high side, ditto a zero line
	      from low to high. Use the NZVC from the high side only.
	      Or, if you get adventurous, send some spare bits from each
              half to the other to do 1-, 2- and perhaps 3-bit shifts.
- clock:      Unchanged.

In total:     4+2+1+1+2+3+2+1=16 chips, two more for the UART=18 chips

You'd be able to use a single register (A or B) to connect to the UART
for 8-bit output. I still can't think of a simple way to do UART input.

Possible idea: connect the UART to the ALU->RAM lines. Output becomes
PASSA + Aload + Bload + RAMwrite, and the UART reads from the bus.
For input, it can place data on the bus which can be loaded with an
Aload or Bload. What we'd need is a way to disable the ALU, so we would
have to split the RAMwrite signal into two separate signals.

Sunday 29 October  09:01:21 AEST 2017
-------------------------------------
E-mail from Chris, he's suffering UART output issues too. I had another
look at the datasheet for the UM254R. Looks like /TXE has to go high
after /WE goes low, but the delay can be as low as 0ns. So perhaps
a NOT on the /WE signal to turn it into the /TXE signal?

Mon  6 Nov 08:11:45 AEST 2017
-----------------------------
It's been a while. Chris found that using two cascaded ORs with Aload, Bload
and Clk seems to fix the UART output. That implies the UART fires on falling
clock signal. He has now got an LCD display attached to the CPU which is
truly amazing.

I've decided to rewire the whole CPU, so that the chips are more evenly
spread out across three breadboards. It's given me a chance to video the
build stages, with descriptions of specific components and to show some
testing. I've done the ALU, A & B registers and the multiplexer.

Just realised that the Flags register should have /PE wired to RAMwrite
as per the csim simulation. All the schematics have it wired low. I've
told Chris that it should be wired to RAMwrite.

Monday 6 November  17:45:24 AEST 2017
-------------------------------------
Chris asked for a cas change to make it easier to enter in 2D instructions.
Taking his suggestion and modifying it, I was able to get it so we can
leave out the NZVC words for simple positional instructions, and to leave
out the "xx" when checking flags. Nzxx becomes just Nz. Works. I've just
updated all the examples and the instructions. Chris has sent in some more
examples.

Monday 6 November  22:18:33 AEST 2017
-------------------------------------
Over the past few days, I've been rebuilding the breadboard CSC to be CSCv2.
As I go, I've been doing some videos of the build, explaining the components
and showing how they can be tested. So far: ALU, A & B regs, multiplexer.
Tonight I wired up the Flags register and the data side of the RAM. Subtle
bug: I hadn't wired the RAM's /CE line low, so I was seeing 2V on its
outputs :) Now fixed and it's working. I've got a test program which I'll
run by hand to load constants into A, store in RAM, fetch them back to verify
that they were stored OK. Tomorrow is Melb Cup day but I hope I can do a
quick video in the morning.
