#!/usr/bin/perl
#
# Simulator for Warren's crazy small CPU.
# (c) 2017 Warren Toomey, GPL3.
#
# Usage: ./csim [-d] [-c clockspeed]
#
#	-d turns on debugging output
#
#	-c 1000 simulates a 1,000 Hz clock speed
#
use strict;
use warnings;
use Data::Dumper;
use Time::HiRes qw( usleep);

# String versions of ALU operations and flag combinations
my @ALUopname = (
    'DADD ', 'DSUB ', 'AND  ', 'OR   ', 'XOR  ', 'INCA ', 'BFLGS', 'ZERO ',
    'ADD  ', 'SUB  ', 'PASSA', 'PASSB', 'MULLO', 'MULHI', 'DIV  ', 'MOD  '
);

my @FLstr = (
    'nzvc', 'nzvC', 'nzVc', 'nzVC', 'nZvc', 'nZvC', 'nZVc', 'nZVC',
    'Nzvc', 'NzvC', 'NzVc', 'NzVC', 'NZvc', 'NZvC', 'NZVc', 'NZVC',
);

my @TopRom;
my @BotRom;
my @ALURom;
my @Ram    = (0) x 256;
my $debug  = 0;
my $udelay = 0;           # usleep delay

# Get any optional arguments
while ( defined( $ARGV[0] ) && ( $ARGV[0] =~ m{^-} ) ) {
    # -d: debug
    if ( $ARGV[0] eq "-d" ) {
        $debug = 1; shift(@ARGV); next;
    }

    # -c: clock rate
    if ( $ARGV[0] eq "-c" ) {
        shift(@ARGV); $udelay = int( 1000000 / shift(@ARGV) );
        $|++; next;
    }
}

# Load in the three ROMs
open( my $IN, "<", "toprom.rom" ) || die("Can't open toprom.rom: $!\n");
<$IN>;
while (<$IN>) {
    chomp; push( @TopRom, map( { hex($_) } split( /\s+/, $_ ) ) );
}
close($IN);
open( $IN, "<", "botrom.rom" ) || die("Can't open botrom.rom: $!\n");
<$IN>;
while (<$IN>) {
    chomp; push( @BotRom, map( { hex($_) } split( /\s+/, $_ ) ) );
}
close($IN);
open( $IN, "<", "alu.rom" ) || die("Can't open alu.rom: $!\n");
<$IN>;
while (<$IN>) {
    chomp; push( @ALURom, map( { hex($_) } split( /\s+/, $_ ) ) );
}
close($IN);

my ( $PC, $NZVC, $A, $B ) = ( 0, 0, 0, 0 );
while (1) {

    # Get the address and control lines from the top and bottom ROMs
    my $romaddr  = ( $NZVC << 8 ) + $PC;
    my $address  = $BotRom[$romaddr];
    my $ALUop    = $TopRom[$romaddr] & 0x7;
    my $PCincr   = ( $TopRom[$romaddr] >> 3 ) & 0x1;
    my $Aload    = ( $TopRom[$romaddr] >> 4 ) & 0x1;
    my $Bload    = ( $TopRom[$romaddr] >> 5 ) & 0x1;
    my $Asel     = ( $TopRom[$romaddr] >> 6 ) & 0x1;
    my $RAMwrite = ( $TopRom[$romaddr] >> 7 ) & 0x1;

    # Calculate the address for the ALU ROM
    my $Cin = $NZVC & 1;
    my $aluaddr =
      ( $Asel << 12 ) + ( $Cin << 11 ) + ( $ALUop << 8 ) + ( $A << 4 ) + $B;

    # Print out some debugging
    printf( "PC %02x %s address %02x cntrl %02x",
        $PC, $FLstr[$NZVC], $address, $TopRom[$romaddr] ) if ($debug);

    # Increment or jump the PC
    if ($PCincr) {
        $PC++;
    }
    else {
        exit(0) if ( $PC == $address );
        $PC = $address;
        printf( ", JXX    PC now %x", $PC ) if ($debug);
    }

    # Output an ASCII character
    if ( ( $Aload == 0 ) && ( $Bload == 0 ) ) {
        print( chr( ( $A << 4 ) + $B ) ) if ( !$debug );
        printf( ", Printed %02x '%s'", ( $A << 4 ) + $B, chr( ( $A << 4 ) + $B ) )
          if ($debug);
    }

    # Perform an ALU instruction
    if ( $RAMwrite == 0 ) {    # Active low
	# Prepend Asel so we print the right opname
	$ALUop |= ($Asel) ? 0x8 : 0x0;
        printf( ", %s: A %x B %x Cin %d", $ALUopname[$ALUop], $A, $B, $Cin )
          if ($debug);

        # Get the result and the new flags value
        my $result = $ALURom[$aluaddr] >> 4;
        $NZVC = $ALURom[$aluaddr] & 0xf;

        $Ram[$address] = $result;
        printf( ", RAM %02x now %x, %s", $address, $result, $FLstr[$NZVC] )
          if ($debug);
    }

    # Load the A register
    if ( $Aload == 0 ) {    # Active low
        if   ($Asel) { $A = $Ram[$address]; }
        else         { $A = $address & 0xf; }
        printf( ", Aload  A now %x", $A ) if ($debug);
    }

    # Load the B register
    if ( $Bload == 0 ) {    # Active low
        if   ($Asel) { $B = $Ram[$address]; }
        else         { $B = $address & 0xf; }
        printf( ", Bload  B now %x", $B ) if ($debug);
    }
    usleep($udelay) if ($udelay);

    print("\n") if ($debug);
}
